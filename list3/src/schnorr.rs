use sha2::{Digest, Sha256};
use crypto_bigint::{Random, RandomMod, NonZero, Integer, MulMod, SubMod};
use crypto_bigint::Zero;
use crypto_bigint::rand_core::OsRng;

// We need a trait that covers both Multiplicative (Fields) and Additive (Curves) groups.
// To unify, we'll use "Group" terminology:
// - generator() -> G
// - op(A, B) -> A * B (or A + B)
// - scal_mul(A, s) -> A^s (or s*A)

pub trait Group {
    type Element: Clone + PartialEq + std::fmt::Debug;
    type Scalar: Integer + Random + RandomMod + Clone + Copy + Zero + MulMod + SubMod; 

    fn generator(&self) -> Self::Element;
    fn order(&self) -> Self::Scalar;
    
    // s * G
    fn scale_gen(&self, s: &Self::Scalar) -> Self::Element;
    
    // s * E
    fn scale_elem(&self, elem: &Self::Element, s: &Self::Scalar) -> Self::Element;
    
    // A + B (or A * B)
    fn operate(&self, a: &Self::Element, b: &Self::Element) -> Self::Element;

    // Encoding for the hash: e = H(R || m)
    fn encode_element(&self, elem: &Self::Element) -> String;
    
    // Convert hash bytes to Scalar
    fn hash_to_scalar(&self, bytes: &[u8]) -> Self::Scalar;
}

pub struct Schnorr<G: Group> {
    group: G,
}

pub struct Signature<S> {
    pub s: S,
    pub e: S, 
}

impl<G: Group> Schnorr<G> {
    pub fn new(group: G) -> Self {
        Self { group }
    }

    pub fn keygen(&self) -> (G::Scalar, G::Element) {
        let q = self.group.order();
        let sk = generate_random_scalar(&q);
        let pk = self.group.scale_gen(&sk);
        (sk, pk)
    }

    pub fn sign(&self, sk: &G::Scalar, msg: &str) -> Signature<G::Scalar> {
        let q = self.group.order();
        
        // 1. k <- Zq
        let k = generate_random_scalar(&q);
        
        // 2. R = g^k
        let r_val = self.group.scale_gen(&k);
        
        // 3. Encode R
        let r_str = self.group.encode_element(&r_val);
        
        // 4. e = H(R || m)
        let e_val = self.compute_challenge(&r_str, msg);
        
        // 5. s = k - x*e mod q
        // s = (k - (x*e)%q + q) % q
        let xe = sk.mul_mod(&e_val, &q);
        let s = k.sub_mod(&xe, &q); 
        
        Signature { s, e: e_val }
    }

    pub fn verify(&self, pk: &G::Element, msg: &str, sig: &Signature<G::Scalar>) -> bool {
        // Verify: R' = g^s * y^e
        let gs = self.group.scale_gen(&sig.s);
        let ye = self.group.scale_elem(pk, &sig.e);
        let r_prime = self.group.operate(&gs, &ye);
        
        let r_str = self.group.encode_element(&r_prime);
        let e_prime = self.compute_challenge(&r_str, msg);
        
        e_prime == sig.e
    }
    
    fn compute_challenge(&self, r_str: &str, msg: &str) -> G::Scalar {
        let mut hasher = Sha256::new();
        // Prompt says: e = SHA256('"000011"Alice') for Encode(17)="000011".
        // This suggests: SHA256( concat( R_str, msg ) )
        // Assuming R_str is the JSON string.
        let input = format!("{}{}", r_str, msg);
        hasher.update(input.as_bytes());
        let hash = hasher.finalize();
        self.group.hash_to_scalar(hash.as_slice())
    }
}

fn generate_random_scalar<S: Integer + Random + RandomMod + Zero + Clone>(modulus: &S) -> S {
    let mut rng = OsRng;
    let non_zero_modulus = NonZero::new(modulus.clone()).unwrap(); // Assumes modulus is not zero, which is true for group order
    S::random_mod(&mut rng, &non_zero_modulus)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crypto_bigint::{U256, NonZero, Encoding};
    use list2::{FpElement, Serializable, FieldElement};

    struct RealFpGroup {
        g: FpElement,
        q: U256,
    }

    impl Group for RealFpGroup {
        type Element = FpElement;
        type Scalar = U256;

        fn generator(&self) -> Self::Element { self.g.clone() }
        fn order(&self) -> Self::Scalar { self.q }
        fn scale_gen(&self, s: &Self::Scalar) -> Self::Element { self.g.pow(s) }
        fn scale_elem(&self, elem: &Self::Element, s: &Self::Scalar) -> Self::Element { elem.pow(s) }
        fn operate(&self, a: &Self::Element, b: &Self::Element) -> Self::Element { *a * *b }
        fn encode_element(&self, elem: &Self::Element) -> String { elem.serialize("hex") }
        fn hash_to_scalar(&self, bytes: &[u8]) -> Self::Scalar {
            let mut padded = [0u8; 32];
            let diff = 32usize.saturating_sub(bytes.len());
            for (i, b) in bytes.iter().enumerate() {
                if i + diff < 32 {
                    padded[i + diff] = *b;
                }
            }
            let val = U256::from_be_bytes(padded);
            let nz_q = NonZero::new(self.q).unwrap();
            val.rem(&nz_q)
        }
    }

    fn setup_group() -> RealFpGroup {
        // P = 23, order of group generated by 2 is 11.
        let p = U256::from(23u64);
        let g_val = U256::from(2u64);
        let q = U256::from(11u64);
        let g = FpElement::new(g_val, p).unwrap();
        RealFpGroup { g, q }
    }

    #[test]
    fn test_schnorr_correctness() {
        let group = setup_group();
        let schnorr = Schnorr::new(group);
        let (sk, pk) = schnorr.keygen();
        let msg = "test message";
        let sig = schnorr.sign(&sk, msg);
        assert!(schnorr.verify(&pk, msg, &sig));
    }

    #[test]
    fn test_schnorr_invalid_message() {
        let group = setup_group();
        let schnorr = Schnorr::new(group);
        let (sk, pk) = schnorr.keygen();
        let sig = schnorr.sign(&sk, "message 1");
        assert!(!schnorr.verify(&pk, "message 2", &sig));
    }

    #[test]
    fn test_schnorr_invalid_signature_s() {
        let group = setup_group();
        let schnorr = Schnorr::new(group);
        let (sk, pk) = schnorr.keygen();
        let msg = "test message";
        let mut sig = schnorr.sign(&sk, msg);
        
        // Tamper with s
        // s is a scalar (U256). We just add 1 mod q or just add 1.
        let one = U256::ONE;
        sig.s = sig.s.wrapping_add(&one);
        
        assert!(!schnorr.verify(&pk, msg, &sig), "Verification should fail when s is tampered");
    }

    #[test]
    fn test_schnorr_invalid_signature_e() {
        let group = setup_group();
        let schnorr = Schnorr::new(group);
        let (sk, pk) = schnorr.keygen();
        let msg = "test message";
        let mut sig = schnorr.sign(&sk, msg);
        
        // Tamper with e
        let one = U256::ONE;
        sig.e = sig.e.wrapping_add(&one);
        
        assert!(!schnorr.verify(&pk, msg, &sig), "Verification should fail when e is tampered");
    }
}


    
